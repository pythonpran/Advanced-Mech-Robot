#include <ICM_20948.h>
ICM_20948_I2C myICM;
#include <AStar32U4Motors.h>
AStar32U4Motors m; //read the documentation of this library to understand what functions to use to drive the motors and how to use them
#include <Encoder.h>
#include <QTRSensors.h>

#define SERIAL_PORT Serial
#define WIRE_PORT Wire
#define AD0_VAL 1  // Default for SparkFun breakout (ADR jumper open)
#define PI 3.141592653589

QTRSensors qtr;

const byte numChars = 32;
char receivedChars[numChars];
char tempChar[numChars]; // temporary array used for parsing

//motor command variables
float leftMotor=0; 
float rightMotor=0;

boolean newData = false;
int calibBool = 0;

const int BUTTON_PIN = 17; 
bool lastButtonState = HIGH;

const int BUTTON_PIN2 = 14; 
bool lastButtonState2 = HIGH;

float target2;
int offset = 5;
bool AlignBool = false;

// Calibration variables
float magMin[3] = { 9999, 9999, 9999 };
float magMax[3] = {-9999,-9999,-9999 };
float magOffset[3] = {0, 0, 0};

float heading;

int startAligning = 0;

const uint8_t SensorCount = 8;
uint16_t sensorValues[SensorCount];
uint16_t linePosition;
int isCross=0;

const int encoderRightPinA = 15;
const int encoderRightPinB = 16;
const int encoderLeftPinA = 11;
const int encoderLeftPinB = 8;

Encoder encoderRight(encoderRightPinA, encoderRightPinB);
Encoder encoderLeft(encoderLeftPinA, encoderLeftPinB);

const int encoderResolution = 1440;  // counts per revolution
const double d = 2.7559055; // inches
const int interval = 15; // control loop every 5 ms (200 Hz)

// ================= PID VARIABLES =================
float Kp_l = 2.1;
float Ki_l = 0.06;
float Kd_l = 0;

float Kp_r = 2.3;
float Ki_r = 0.07;
float Kd_r = 0;
                                                                                                                                                                                             ;
const double leftMotorMax = 39.41;
const double leftMotorMin = -40.35;
const double rightMotorMax = 35.74;
const double rightMotorMin = -39.14;

int posLeftCountLast = 0;
int posRightCountLast = 0;

int corr_r = 1;
int corr_l = 1;

float leftMotorCmd = 0;
float rightMotorCmd = 0;

double newVelLeft = 0, newVelRight = 0;
double velLeft = 0, velRight = 0;
float diffRight=0;
float diffLeft=0;
float posLeftRad = 0.0; // this will need to be converted to rad/sec
float posRightRad = 0.0; // this will need to be converted to rad/sec
int posLeftCount = 0;
int posRightCount = 0;
unsigned long currentMillis;
unsigned long prevMillis = 0;
double dtlastL = 0;double dtL = 0;
double dtlastR = 0;double dtR = 0;
double interval2L;
double interval2R;
unsigned long priorTimeL;
double lastSpeedErrorL;
double cumErrorL;
unsigned long priorTimeR;
double lastSpeedErrorR;
double cumErrorR;
double maxErr = 20;

int counter = 0;
int doneRot=0;
int start = 0;
   
void setup()
{
  SERIAL_PORT.begin(9600);
  while (!SERIAL_PORT) {}
  
  pinMode(3, OUTPUT); //left motor
  pinMode(2,OUTPUT); //Right motor 
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(BUTTON_PIN2, INPUT_PULLUP); 

  qtr.setTypeRC(); //this allows us to read the line sensor from digital pins

    //arduino pin sensornames I am using: 7, 18, 23 aka A5. note:PIN A1 DID NOT WORK WITH ANY SENSOR!!, 20, 21, 22, 8, 6. UNHOOK THE BLUE JUMPER LABELED BUZZER ON THE ASTAR or pin 6 will cause the buzzer to activate.
    //qtr.setSensorPins((const uint8_t[]){7, 18, 23, 20, 21, 22, 4, 6}, SensorCount);
    //qtr.setSensorPins((const uint8_t[]){4, 6, 23, 22, 23, 19, 20, 21}, SensorCount);
    qtr.setSensorPins((const uint8_t[]){18, 7, 20, 21, 22, 23, 6, 4}, SensorCount);
    qtr.setEmitterPin(5); //can get away with a single emitter pin providing power to both emitters
    QTRReadMode::On; //emitters on measures active reflectance instead of ambient light levels, better becasue the ambient light level will change as the robot moves around the board but the reflectance levels will not
     
  WIRE_PORT.begin();
  WIRE_PORT.setClock(400000);

  bool initialized = false;
  while (!initialized)
  {
    myICM.begin(WIRE_PORT, AD0_VAL);
    //SERIAL_PORT.print("Initialization status: ");
    //SERIAL_PORT.println(myICM.statusString());
    if (myICM.status != ICM_20948_Stat_Ok)
    {
      SERIAL_PORT.println("Retrying...");
      delay(500);
    }
    else
    {
      initialized = true;
    }
  }

  //SERIAL_PORT.println("ICM initialized!");

}

void loop()
{
    currentMillis = millis();
    posRightCount = encoderRight.read(); 
    posLeftCount = encoderLeft.read();

    recvWithStartEndMarkers(); //this function is in charge of taking a peice of data that looks like <17,16> 
                               //turning it into a string looking like 17,16 and then setting newdata to true,
                               //letting the rest of the program know a packet of data is ready to be analyzed, does all this without blocking
    if (newData == true) { //newData will be true when recvWithStartEndMarkers(); has finished recieving a whole set of data from Rpi (a set of data is denoted as being containted between <>)
      
      strcpy(tempChar, receivedChars); //this line makes a copy of recievedChars for parsing in parseData, I do this becasue strtok() will alter any string I give it,I want to preserve the origonal data
      parseData(); //right now parseData only parses a string of 2 numbers seperated by commas into floats
                   //so the string 17.5,16 becomes two floats; 17.5 and 16


      //below this comment and between setting newData to false is where you want to send the Rpi whatever data you want.
      ReadData();
      Serial.print(startAligning);
      Serial.print(",");
      Serial.print(linePosition);
      Serial.print(",");
      Serial.print(isCross);
      Serial.print(",");
      Serial.print(heading);
      Serial.print(",");
      //Serial.print(target2);
      //Serial.print(",");
      Serial.println(doneRot);
      //Serial.print(",");
      //Serial.print(leftMotor);
      //Serial.print(",");
      //Serial.println(start);

      newData = false;

      //sendDataToRpi(); //unused
                   
    }
    
    bool buttonState2 = digitalRead(BUTTON_PIN2);

    if (lastButtonState2 == HIGH && buttonState2 == LOW) {
  
      startAligning = 1;
      //ReadData();
      //Align(heading+90);
    }
    lastButtonState2 = buttonState2;
    
    bool buttonState = digitalRead(BUTTON_PIN);

    if (lastButtonState == HIGH && buttonState == LOW) {
      counter=counter+1;
      if (counter == 1){
  
        calibrateMagnetometer(15000); // 15 seconds
        SERIAL_PORT.println("Compass Calibration complete!");
   
      } else if (counter ==2) {
          calibrateSensors();
          SERIAL_PORT.println("Line Following Calibration complete!");
        }
      

    }

    lastButtonState = buttonState;

    //////////////////////////////////////////REPAIRING THE READLINEBLACK FUNCTION SO THE LINEPOSITION VARIABLE IS ACTUALLY USEFULL FOR STUDENTS//////////////////////////////////////////////
    
    linePosition = qtr.readLineBlack(sensorValues);
    
    //REPAIR NUMBER ONE:  every sensor reading under 300 is a noisy and messes up the lineposition measurment, so this for loop filters it out
    for (int i=0; i<= 7; i++){
       if (sensorValues[i] <300){
           sensorValues[i]=0;     
        }
    //Serial.print(sensorValues[i]);
    //Serial.print('\t');
    }
    
    // REPAIR NUMBER 2: checking if all my sensorvalues are zero and then setting lineposition to zero,sometimes if all sensorvalues are zero lineposition will be set to 7k and this fixes that
    if (sensorValues[0]==0 && sensorValues[1]==0 && sensorValues[2]==0 && sensorValues[3]==0 && sensorValues[4]==0 && sensorValues[5]==0 && sensorValues[6]==0 && sensorValues[7]==0){
      linePosition=0;
    }
    
    //REPAIR NUMBER THREE: if only sensor 0 or sensor 8 are reading measurments, then the low level function that calculates linePosition will set it to values that dare not representative of where the sensor array
    //is actually located relative to the line, the below loops fix that by setting linePosition to  1000 if ONLY sensor 0 sees anything, and setting linePosition to 5000 if ONLY sensor 7 sees anything
    if (sensorValues[0] >0 && sensorValues[1]==0 && sensorValues[2]==0 && sensorValues[3]==0 && sensorValues[4]==0 && sensorValues[5]==0 && sensorValues[6]==0 && sensorValues[7]==0){
      linePosition=1000;
    } 
    if (sensorValues[7] >0 && sensorValues[0]==0 && sensorValues[1]==0 && sensorValues[2]==0 && sensorValues[3]==0 && sensorValues[4]==0 && sensorValues[5]==0 && sensorValues[6]==0){
      linePosition=5000;
    }
    
    //REPAIR NUMBER 4: there are still situations where linePosition is somehow greater than 5000 or 0<linePosition<1000, so I am hard capping linePosition to be between 1000 and 5000 when linePosition is greater
    //than zero.
    if (linePosition > 5000){
      linePosition = 5000;
    }
    if (linePosition < 1000 && linePosition > 0){
      linePosition = 1000;
    }
    
    //this loop uses the leftmost and rightmost sensors to determine if the robot is at a cross. If both of those sensors read high, then the robot is at a cross. 
    if ((sensorValues[7] > 500) && (sensorValues[0] > 500)){
      isCross = 1;
    }else{
        isCross = 0;
      }
    //Serial.println(linePosition);
//      Serial.print(sensorValues[0]);
//      Serial.print(",");
//      Serial.print(sensorValues[1]);
//      Serial.print(",");
//      Serial.print(sensorValues[2]);
//      Serial.print(",");
//      Serial.print(sensorValues[3]);
//      Serial.print(",");
//      Serial.print(sensorValues[4]);
//      Serial.print(",");
//      Serial.print(sensorValues[5]);
//      Serial.print(",");
//      Serial.print(sensorValues[6]);
//      Serial.print(",");
//      Serial.println(sensorValues[7]);
//      delay(50);
    //now linePosition returns a value between 1000 and 5000 that is proportonal to the sensor's position relative to the line, and the value isCross is set to 1 when both sensor 0 and 7 are over a line


//////////////////////////////////////////////////////////////////////////////////////////////////////////END OF REPAIRS TO LINEPOSITION///////////////////////////////////////////////////////////////////////////
    
    if (currentMillis - prevMillis >= 3*interval) {
    prevMillis = currentMillis;
    //leftMotor = 5;//Tuning
    //rightMotor = 5;//Tuning
    velLeft = computeLinearVelocityLeft();
    velRight = computeLinearVelocityRight();
    newVelLeft = drivePIDL(velLeft, leftMotor, corr_l*Kp_l, corr_l*Ki_l, corr_l*Kd_l);
    newVelRight = drivePIDR(velRight, rightMotor, corr_r*Kp_r, corr_r*Ki_r, corr_r*Kd_r);
    leftMotorCmd = motorVelToSpeedCommand(velLeft+newVelLeft, leftMotorMax, leftMotorMin);
    rightMotorCmd = motorVelToSpeedCommand(velRight+newVelRight, rightMotorMax, rightMotorMin);
    commandMotors(leftMotorCmd,rightMotorCmd);
    //commandMotors(-400,0);

    //Serial.println(newVelLeft);
    //Serial.print(", ");
    //Serial.println(leftMotorCmd);
    //Serial.print(encoderLeft.read());
    //Serial.print(", ");
    //Serial.println(encoderRight.read());
    }
    //AlignBool = true;
    doneRot = 0;
    Align(target2);

}

void calibrateMagnetometer(unsigned long durationMs)
{
  unsigned long startTime = millis();
  SERIAL_PORT.println("Rotate the sensor in all directions...");

  while (millis() - startTime < durationMs)
  {
    if (myICM.dataReady())
    {
      myICM.getAGMT();
      float mx = myICM.magX();
      float my = myICM.magY();
      float mz = myICM.magZ();

      // Update min/max
      if (mx < magMin[0]) magMin[0] = mx;
      if (my < magMin[1]) magMin[1] = my;
      if (mz < magMin[2]) magMin[2] = mz;
      if (mx > magMax[0]) magMax[0] = mx;
      if (my > magMax[1]) magMax[1] = my;
      if (mz > magMax[2]) magMax[2] = mz;

      SERIAL_PORT.print(".");
      delay(100);
    }
  }

  // Compute offsets (bias)
  for (int i = 0; i < 3; i++)
  {
    magOffset[i] = (magMax[i] + magMin[i]) / 2.0;
  }

  //SERIAL_PORT.println();
  //SERIAL_PORT.println("Calibration results:");
  //SERIAL_PORT.print("Min: [ ");
  //printFormattedFloat(magMin[0], 6, 2); SERIAL_PORT.print(", ");
  //printFormattedFloat(magMin[1], 6, 2); SERIAL_PORT.print(", ");
  //printFormattedFloat(magMin[2], 6, 2); SERIAL_PORT.println(" ]");

  //SERIAL_PORT.print("Max: [ ");
  //printFormattedFloat(magMax[0], 6, 2); SERIAL_PORT.print(", ");
  //printFormattedFloat(magMax[1], 6, 2); SERIAL_PORT.print(", ");
  //printFormattedFloat(magMax[2], 6, 2); SERIAL_PORT.println(" ]");

  //SERIAL_PORT.print("Offsets (bias): [ ");
  //printFormattedFloat(magOffset[0], 6, 2); SERIAL_PORT.print(", ");
  //printFormattedFloat(magOffset[1], 6, 2); SERIAL_PORT.print(", ");
  //printFormattedFloat(magOffset[2], 6, 2); SERIAL_PORT.println(" ]");
}

// =========================================================
void printFormattedFloat(float val, uint8_t leading, uint8_t decimals)
{
  float aval = abs(val);
  if (val < 0) SERIAL_PORT.print("-");
  else SERIAL_PORT.print(" ");

  for (uint8_t indi = 0; indi < leading; indi++)
  {
    uint32_t tenpow = 0;
    if (indi < (leading - 1)) tenpow = 1;
    for (uint8_t c = 0; c < (leading - 1 - indi); c++) tenpow *= 10;
    if (aval < tenpow) SERIAL_PORT.print("0");
    else break;
  }

  if (val < 0) SERIAL_PORT.print(-val, decimals);
  else SERIAL_PORT.print(val, decimals);
}

// =========================================================
void Align(float target)
{
  if (start == 1){
   AlignBool = true;
   target=fmod(target, 360);
   if (target <0){
    target += 360;
   }
   while(AlignBool){
    doneRot = 0;
    currentMillis = millis();
    posRightCount = encoderRight.read(); 
    posLeftCount = encoderLeft.read();
    ReadData();
  if ((heading-target)>offset || (heading-target)<-offset){
      //SERIAL_PORT.println("heading>target");
      //SERIAL_PORT.println(heading);
      if (heading>target and heading - target < 180){
      leftMotor = 2;
      rightMotor = -2;
      //SERIAL_PORT.println("inside");
      } else if (heading<target and target - heading > 180){
      leftMotor = 2;
      rightMotor = -2;
      }else {
      
        leftMotor = -2;
        rightMotor = 2;
      }
      
    if (currentMillis - prevMillis >= interval) {

    prevMillis = currentMillis;
    velLeft = computeLinearVelocityLeft();
    velRight = computeLinearVelocityRight();
    newVelLeft = drivePIDL(velLeft, leftMotor, corr_l*Kp_l, corr_l*Ki_l, corr_l*Kd_l);
    newVelRight = drivePIDR(velRight, rightMotor, corr_r*Kp_r, corr_r*Ki_r, corr_r*Kd_r);
    leftMotorCmd = motorVelToSpeedCommand(velLeft+newVelLeft, leftMotorMax, leftMotorMin);
    rightMotorCmd = motorVelToSpeedCommand(velRight+newVelRight, rightMotorMax, rightMotorMin);
    commandMotors(leftMotorCmd,rightMotorCmd);
    }
    
    delay(500);
    leftMotorCmd = 0;
    rightMotorCmd = 0;
    commandMotors(leftMotorCmd,rightMotorCmd);
    delay(50);
  }else {
    //SERIAL_PORT.println("heading=target");
    //SERIAL_PORT.println(heading);
    leftMotor = 0;
    rightMotor = 0;
    leftMotorCmd = 0;
    rightMotorCmd = 0;
    commandMotors(leftMotorCmd,rightMotorCmd);
    doneRot = 1;
    AlignBool = false;
  }
   }
  }
}

// =========================================================
void ReadData()
{
if (myICM.dataReady())
  {
    myICM.getAGMT();
    float mx = myICM.magX() - magOffset[0];
    float my = myICM.magY() - magOffset[1];
    float mz = myICM.magZ() - magOffset[2];

    // --- Compute heading (in degrees) ---
    // Adjust if sensor orientation differs (you may need to swap/negate axes)
    heading = atan2(my, mx) * 180.0 / PI;
    if (heading < 0) heading += 360.0;

    // --- Print data ---
    //SERIAL_PORT.print("Calibrated Mag (uT): [ ");
    //printFormattedFloat(mx, 6, 2);
    //SERIAL_PORT.print(", ");
    //printFormattedFloat(my, 6, 2);
    //SERIAL_PORT.print(", ");
    //printFormattedFloat(mz, 6, 2);
    //SERIAL_PORT.print(" ]  |  Heading: ");
    //printFormattedFloat(heading, 6, 2);
    //SERIAL_PORT.println("Â°");
  }
  else
  {
    //SERIAL_PORT.println("Waiting for data...");
  } 

}
//======================================================


void parseData(){
  


  char *strtokIndexer; //doing char * allows strtok to increment across my string properly frankly im not sure why... something to do with pointers that I dont expect students to understand

  
  strtokIndexer = strtok(tempChar,","); //sets strtokIndexer = to everything up to the first comma in tempChar /0 //this line is broken
  leftMotor = atof(strtokIndexer); //converts strtokIndexer into a int

  strtokIndexer= strtok(NULL, ","); //setting the first input to null causes strtok to continue looking for commas in tempChar starting from where it left off, im not really sure why 
  rightMotor = atof(strtokIndexer);

  strtokIndexer= strtok(NULL, ","); //setting the first input to null causes strtok to continue looking for commas in tempChar starting from where it left off, im not really sure why 
  target2 = atof(strtokIndexer);

  strtokIndexer= strtok(NULL, ","); //setting the first input to null causes strtok to continue looking for commas in tempChar starting from where it left off, im not really sure why 
  start = atoi(strtokIndexer);
  
  //now that we have extracted the data from the Rpi as floats, we can use them to command actuators somewhere else in the code
  
}

//==========================================


//=======================================

void commandMotors(float leftMotorCMD,float rightMotorCMD){
  m.setM1Speed(leftMotorCMD);
  m.setM2Speed(rightMotorCMD);
}


//=========================================================


void recvWithStartEndMarkers() {
    static boolean recvInProgress = false;
    static byte ndx = 0;
    char startMarker = '<';
    char endMarker = '>';
    char rc;
                                                               
    while (Serial.available() > 0 && newData == false) {
        rc = Serial.read();
                                                             
                                                                  
        if (recvInProgress == true) {
            if (rc != endMarker) {
                receivedChars[ndx] = rc;
                ndx++;
                if (ndx >= numChars) {
                    ndx = numChars - 1;
                }
            }
            else {
                receivedChars[ndx] = '\0'; // terminates the string, frankly unsure why I need this
                recvInProgress = false;
                ndx = 0;
                newData = true;
            }
        }

        else if (rc == startMarker) {
            recvInProgress = true;
        }
    }
}

//==================================================================


// ================== PID FUNCTION ==================
double drivePIDL(double curr, double setpoint, double kp, double ki, double kd) {

    double rateErrorL;
    double errorL;
    unsigned long currentTimeL;
    unsigned long elapsedTimeL;
    cumErrorL = 0;
    
    currentTimeL = millis();                               //get current time
    elapsedTimeL = (double)(currentTimeL - priorTimeL);      // compute elasped time for this control period

    errorL = setpoint - curr;                                   // Error

    cumErrorL += errorL*elapsedTimeL;                       // Cumulative Error(since we add this outside the loop, needs to be unique to the motor controlled)

    // INTEGRAL WINDUP                                    // REMOVE WINDUP
    if(cumErrorL>maxErr)
      cumErrorL = maxErr;
    else if (cumErrorL<-1*maxErr)
      cumErrorL = -1*maxErr;

    rateErrorL = (errorL-lastSpeedErrorL)/elapsedTimeL;      // Derivative Error

    double outL =( kp*errorL+ki*cumErrorL+kd*rateErrorL );   // PID output
    //Serial.print("outLeft:");
    //Serial.println(outL);
    lastSpeedErrorL = errorL;                              // remember current error
    priorTimeL = currentTimeL;                             // remember current time
    return outL;                                           // return the needed motor speed. 
}
double drivePIDR(double curr, double setpoint, double kp, double ki, double kd) {

    double rateErrorR;
    double errorR;
    unsigned long currentTimeR;
    unsigned long elapsedTimeR;
    cumErrorR = 0;
    
    currentTimeR = millis();                               //get current time
    elapsedTimeR = (double)(currentTimeR - priorTimeR);      // compute elasped time for this control period

    errorR = setpoint - curr;                                   // Error
    cumErrorR += errorR*elapsedTimeR;                       // Cumulative Error(since we add this outside the loop, needs to be unique to the motor controlled)

    // INTEGRAL WINDUP                                    // REMOVE WINDUP
    if(cumErrorR>maxErr)
    cumErrorR = maxErr;
    else if (cumErrorR<-1*maxErr)
      cumErrorR = -1*maxErr;

    rateErrorR = (errorR-lastSpeedErrorR)/elapsedTimeR;      // Derivative Error

    double outR = kp*errorR+ki*cumErrorR+kd*rateErrorR;   // PID output
    //Serial.print("outRight:");
    //Serial.println(outR);
    //Serial.println(outR);
    lastSpeedErrorR = errorR;                              // remember current error
    priorTimeR = currentTimeR;                             // remember current time
    return outR;                                           // return the needed motor speed. 
}

// ================== MOTOR MAPPING ==================
int motorVelToSpeedCommand(double Vel, double maxVel, double minVel) {
  Vel = constrain(Vel, minVel, maxVel);
  return map(Vel, minVel, maxVel, -400, 400);

}

double computeLinearVelocityRight() {
     dtR=millis();
     interval2R = dtR-dtlastR;
     yield();
     posRightCount = encoderRight.read();
     diffRight = posRightCount - posRightCountLast;
     posRightRad = ((2*PI)/encoderResolution)*(diffRight/interval2R)*1000; 
     velRight = (d/2)*posRightRad; // Now convert to get inches/sec (tangential velocity)
     //Serial.print("velRight:");
     //Serial.println(velRight);
     posRightCountLast = posRightCount;
     dtlastR=dtR;
  return velRight;
}

 //================== ENCODER VELOCITY LEFT ==================
double computeLinearVelocityLeft() {
     dtL=millis();
     interval2L = dtL-dtlastL;
     yield();
     posLeftCount = encoderLeft.read();
     diffLeft = posLeftCount - posLeftCountLast;

     posLeftRad = ((2*PI)/encoderResolution)*(diffLeft/interval2L)*1000;
      
     velLeft = (d/2)*posLeftRad; // Now convert to get inches/sec (tangential velocity)
     //Serial.print("velLeft:");
     //Serial.println(velLeft);
     posLeftCountLast = posLeftCount;
     dtlastL=dtL;
  return velLeft;
}

//==================================================================

void calibrateSensors(){

  //THE SENSORS ONLY CALIBRATE WHEN YOU UPLOAD NEW ARDUINO CODE TO THE ASTAR. after that the sensors STAY calibrated as long as the Astar has power.
  Serial.println("Move the Line Following sensors above the black line");
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, HIGH); // turn on Arduino's LED to indicate we are in calibration mode
                                   ///while calibrating, move the sensor over the line a couple times

  // 2.5 ms RC read timeout (default) * 10 reads per calibrate() call
  // = ~25 ms per calibrate() call.
  // Call calibrate() 400 times to make calibration take about 10s seconds.
  for (uint16_t i = 0; i < 400; i++)
  {
    qtr.calibrate();
  }
  digitalWrite(LED_BUILTIN, LOW); // turn off Arduino's LED to indicate we are through with calibration

  //Serial.print("Calibrated Maximum ");
  //for(uint8_t i = 0; i < 8; i++){
    //Serial.print(qtr.calibratedMaximumOn[i]);
    //Serial.print('\t');
  //}  
  //Serial.print("Calibrated Mimum ")
  //for(uint8_t i = 0; i < 8; i++){
    //Serial.print(qtr.calibratedMinimumOn[i];
    //Serial.print('\t');
  //} 
}
